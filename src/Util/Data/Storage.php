<?php
/**
 * Created by Kutuzov Alexey Konstantinovich <lexus.1995@mail.ru>.
 * Author: Kutuzov Alexey Konstantinovich <lexus.1995@mail.ru>
 * Project: jungle
 * IDE: PhpStorm
 * Date: 02.06.2016
 * Time: 11:29
 */
namespace Jungle\Util\Data {

	use Jungle\Util\Data\Storage\StorageInterface;

	/**
	 * Class SourceManager
	 * @package modelX
	 *
	 * map conversion [sys] => [origin]
	 * Select:
	 * ordering
	 * grouping
	 * column list
	 *
	 * Схемой можно ограничить предоставляемые поля
	 *  Допустим у схемы есть поля `id`, `name`, `city`, `created_at`
	 *
	 *  Мы хотим чтобы выборка по схеме происходила только для полей `id`, `name`, `city` исключив поле `created_at`
	 *  Такие схемы могут производить полую выборку по оригиналу,
	 * а могут производить умную выборку - но тогда где-то в коллекции будет урезаная запись по такой схеме.
	 * При этом при попытке доступа уже к оригинальной схеме произойдет выбор решения:
	 * Либо использовать уже загруженую запись по урезаной схеме что требует актуализировать недостоющие поля,
	 * Либо использовать новый запрос для обновления такой
	 *
	 * Схему можно дополнить какими-то полями:
	 *
	 * Создав виртуальные поля, такие поля требуют Getter\Setter доступа к оригиналу данных,
	 * или же использовав доступ к текущей схеме (FormulaGetter\FormulaSetter),
	 * где мы получим данные соответствующие реальным типам переменных.
	 *
	 * Поля связей по внешним ключам тоже можно прировнять к виртуальным полям с приставкой Relation, НО
	 * объекты по связям нужно использовать в стиле LazyLoad с использованием соответствующих коллекций и связаных схем.
	 *
	 * В случае если мы хотим добавить в текущую схему допустим поле `password`, которого в принципе нету в оригинальной схеме
	 * тогда встает вопрос о выборке этого поля из другой схемы в которой есть поля этой семантики.
	 *      Выбрать данные такого поля сопоставив записи как-то по ключам!
	 *      Получить доступ к записям внешней схемы, точнее к источнику этих записей для постройки запроса,
	 *          Или найти запись по идентификатору в инициированых объектах-записях отобрав нужный.
	 * Таким образом вполне реально создать условия для сливания множества схем в единую посредством примешивания,
	 *
	 * Или же в таблице присутствует такое поле, просто его не добавили в главную схему, тогда мы просто добавляем поле в новой схеме
	 *
	 * @TODO Schema Extending Descendant\Ancestor
	 *
	 *
	 * Прослойка между реальным источником и модельной фасадом,
	 * как видим здесь производятся действия на нижнем уровне взаимодействия с БД
	 *
	 *
	 * @TODO Transfer model field meta data   to   original source field meta data   before use low-level-processing
	 *
	 */
	abstract class Storage implements StorageInterface{

	}
}

